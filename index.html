<!DOCTYPE html>
<html>
   <head>
      <meta charset="utf-8">
      <title>Espacios Homogeneos</title>
      <script src="/scripts/three.js"></script>
      <script src="/scripts/threex.js"></script>
      <script src="/scripts/tween.min.js"></script>
      <script src="/scripts/zTrackballControls.js"></script>
      <script src="/scripts/threex.domevents.js"></script>
      <script src="/scripts/threex.keyboardstate.js"></script>
      <script src="/scripts/zAller_Regular.js"></script>
      <script src="/scripts/Please-compressed.js"></script>
      <script src="/scripts/visualMath.js"></script>
   </head>
   <body>


	<div class="ui very padded" id="vmcontainer">

		<div class="ui card violet vecUI" style="position : fixed; top : 50px; left : 40px ; z-index: 9; opacity:0">
			<div class="content">
				<div class="header">Transformacion Homogenea</div>
				<div class="meta">Introduzca la matriz de transformación que quiere aplicar al objeto mostrado en la animación. <br>
					{{> addformm2}}
				</div>

				<div class="description">
					<div id="katexfield5" class="katexbig">

					</div>
				</div>
			</div>
			<div class="extra content">
				Se aplicara la transformacion de acorde a la matriz ingresada.
			</div>
		</div>
		<div id="explanation">


			<div class = "ui very padded basic container segment center aligned ">
				<div class="ui icon header very big">
					<h1>Espacios Homogéneos</h1>
				</div>
				<div class="ui raised segment justify aligned">
					<h4>
						<br>
						El espacio homogéneo apareció como solución al problema de no poder describir la traslación
						como una matriz 3x3 ya que son límitadas y solamente pueden describir
						transformaciones del tipo escalamiento, rotación, reflexión y deformación.
						<div class="ui divider"></div>
						El espacio homogéneo es un espacio 4 dimensional que permite ver su comportamiento en el espacio 3D tomando una proyección,
						que en realidad es reducir la dimensión del espacio, haciendo una de ellas una constante.
						Al añadir una dimensión a los vectores del espacio 3D, obtenemos una geometría más flexible que
						la geometría euclidiana del plano cartesiano.
					</h4>
				</div>
				<div class="ui grid center aligned">
					<div class="five wide column center aligned">
						<div class="ui red card">
							<div class="header">
								<h3>Vectores o Cuaterniones</h3>
							</div>
							<div class="image katexm margin10 ">
								{{#katex}} 	\begin{pmatrix}x & y & z & w \end{pmatrix}  {{/katex}}
							</div>
							<div class="content">
								<br>
								<a class="description">Los elementos del espacio homogéneo son los vectores o cuaterniones,  las tranformaciones son descritas por matrices 4x4.</a>
							</div>

						</div>
					</div>
					<div class="seven wide column center  aligned">
						<div class="ui raised center aligned segment red">
							<h4> Este espacio puede identificarse con el espacio cartesiano 3D, ya que se puede
								establecer una correspondencia sobreyectiva (se puede cubrir todo el espacio cartesiano) entre
								<div class="katexm">
									{{#katex}}
									\begin{pmatrix}
									x_h \\
									y_h \\
									z_h \\
									w_h
									\end{pmatrix}
									{{/katex}}
									y
									{{#katex}}
									\begin{pmatrix}
									x_c \\
									y_c \\
									z_c
									\end{pmatrix}
									{{/katex}}

								</div>

								Para todos los números {{#katex}}x_h,y_h,z_h,w_h{{/katex}}.</h4>
							</div>
						</div>
					</div>

					<div class="ui horizontal divider">
						<h3>Cambio de Coordenadas</h3>
					</div>
					<div class="ui segment center aligned raised">
						<h4>    El cambio de coordenadas se determina de la siguiente manera, tomando a {{#katex}}w \neq 0{{/katex}} tenemos
							las siguientes implicaciones, tomando al operador {{#katex}}\sim{{/katex}} como la equivalencia de un punto
							en las coordenadas homogéneas con un punto en las coordenadas cartesianas. </h4>

							<div class="katexmid">
								{{#katex}}
								\begin{pmatrix}
								x&
								y&
								z &
								1
								\end{pmatrix}
								\sim
								\begin{pmatrix}
								x&
								y&
								z
								\end{pmatrix}
								\Longrightarrow
								\begin{pmatrix}
								\frac{x}{w}&
								\frac{y}{w}&
								\frac{z}{w} &
								1
								\end{pmatrix}
								\sim
								\begin{pmatrix}
								\frac{x}{w}&
								\frac{y}{w}&
								\frac{z}{w}
								\end{pmatrix}
								{{/katex}}
								<br><br>{{#katex}}
								\begin{pmatrix}
								\frac{x}{w}&
								\frac{y}{w}&
								\frac{z}{w} &
								1
								\end{pmatrix}
								\sim
								\begin{pmatrix}
								\frac{x}{w}&
								\frac{y}{w}&
								\frac{z}{w}
								\end{pmatrix}
								\Longrightarrow
								\begin{pmatrix}
								\frac{x}{w} w&
								\frac{y}{w} w&
								\frac{z}{w} w&
								w
								\end{pmatrix}
								\sim
								\begin{pmatrix}
								\frac{x}{w} &
								\frac{y}{w} &
								\frac{z}{w}
								\end{pmatrix}{{/katex}}
								<br><br>
								{{#katex}}
								\begin{pmatrix}
								\frac{x}{w} w&
								\frac{y}{w} w&
								\frac{z}{w} w&
								w
								\end{pmatrix}
								\sim
								\begin{pmatrix}
								\frac{x}{w} &
								\frac{y}{w} &
								\frac{z}{w}
								\end{pmatrix}
								\Longrightarrow
								\begin{pmatrix}
								x&
								y&
								z&
								w
								\end{pmatrix}
								\sim
								\begin{pmatrix}
								\frac{x}{w} &
								\frac{y}{w} &
								\frac{z}{w}
								\end{pmatrix}
								{{/katex}}
							</div>
						</div>

						<div class="ui horizontal divider">
							Puntos Homogeneos
						</div>
						<div class="ui segment raised center aligned">
							<br><h4>
								Algunos ejemplos de cambio de coordenadas homogeneas a cartesianas son
								<div class="ui center aligned">
									<div class="segment raised red margin10">
										<div class="image katexmid">
											{{#katex}}\begin{pmatrix}
											4 &
											5 &
											2 &
											-2
											\end{pmatrix}
											\sim
											\begin{pmatrix}
											-\frac{4}{2} &
											-\frac{5}{2} &
											-\frac{2}{2}
											\end{pmatrix}
											{{/katex}}<br><br>{{#katex}}
											=
											\begin{pmatrix}
											-2 &
											-\frac{5}{2} &
											-1
											\end{pmatrix}{{/katex}}
										</div>
									</div>
									<div class="segment raised red margin10">
										<div class="image katexmid">
											{{#katex}}\begin{pmatrix}
											8 &
											10 &
											4 &
											-4
											\end{pmatrix}
											\sim
											\begin{pmatrix}
											-\frac{8}{4} &
											-\frac{10}{4} &
											-\frac{4}{4}
											\end{pmatrix}
											{{/katex}}<br><br>{{#katex}}
											=\begin{pmatrix}
											-2 &
											-\frac{5}{2} &
											-1
											\end{pmatrix}{{/katex}}
										</div>
									</div>
								</div>
							</h4>
							<h4>
								Estos ejemplos ilustran el hecho de que a varios puntos del espacio homogéneo se
								le puede asignar un solo punto.
								Estos puntos son llamados <b>puntos homogéneos</b>
							</h4>
						</div>
						<div class="ui horizontal divider">
							<h3>Traslacion</h3>
						</div>
						<div class="ui segment center aligned red"><h4>
							Uno de los usos fundamentales del espacio homogéneo es la traslación de objetos rigidos y
							es descrita por la siguiente matriz <br>
							<br>
							<div class="katexmid margin10">
								{{#katex}}
								\begin{pmatrix}
								1 & 0 & 0 & \Delta x \\
								0 & 1 & 0 & \Delta y \\
								0 & 0 & 1 & \Delta z \\
								0 & 0 & 0 & 1
								\end{pmatrix}
								{{/katex}}
							</div>

							<br>
							<br>
							Donde claramente se ve el uso de la última columna, el argumento {{#katex}} \begin{pmatrix} \Delta x, \Delta y ,\Delta z \end{pmatrix} {{/katex}}
							es el vector cuyo origen es la posición el objeto y su destino es la posición donde queremos ubicarlo.
							<br>
							Si queremos aplicarlo al vector {{#katex}}v=\begin{pmatrix}
							v_{x}\\
							v_{y}\\
							v_{z}\\
							v_{w}
							\end{pmatrix} {{/katex}}, Haremos {{#katex}} v_w=1 {{/katex}} para que las primeras
							tres coordenadas coincidan entre los vectores 3D y 4D. <br>
							<br>
							Entonces realizamos
							<div class="katexmid margin10">
								{{#katex}}\begin{pmatrix}
								1 & 0 & 0 & \Delta x \\
								0 & 1 & 0 & \Delta y \\
								0 & 0 & 1 & \Delta z \\
								0 & 0 & 0 & 1
								\end{pmatrix} \begin{pmatrix}
								v_{x}\\
								v_{y}\\
								v_{z}\\
								1
								\end{pmatrix} = \begin{pmatrix}
								v_{x} + \Delta x \\
								v_{y} + \Delta y \\
								v_{z} + \Delta z \\
								1
								\end{pmatrix}  {{/katex}}
							</div>
						</h4>
					</div>

				</div>
			</div>
		</div>

	<template name="addformm2">
		<form class="matrixinput4 ui fluid input">
			<table class="ui violet table">
				<thead>
					<tr><th>x</th>
						<th>y</th>
						<th>z</th>
						<th>w</th>
					</tr></thead><tbody>
						<tr>
							<td><input type="text" name="a11" class="matrixinput4" value="1"></td>
							<td><input type="text" name="a12" class="matrixinput4" value="0"></td>
							<td><input type="text" name="a13" class="matrixinput4" value="0"> </td>
							<td><input type="text" name="a14" class="matrixinput4" value="0"> </td>
						</tr>
						<tr>
							<td><input type="text" name="a21" class="matrixinput4" value="0"></td>
							<td><input type="text" name="a22" class="matrixinput4" value="1"></td>
							<td><input type="text" name="a23" class="matrixinput4" value="0"></td>
							<td><input type="text" name="a24" class="matrixinput4" value="0"> </td>
						</tr>
						<tr>
							<td><input type="text" name="a31" class="matrixinput4" value="0"></td>
							<td><input type="text" name="a32" class="matrixinput4" value="0"></td>
							<td><input type="text" name="a33" class="matrixinput4" value="1"></td>
							<td><input type="text" name="a34" class="matrixinput4" value="0"> </td>
						</tr>
						<tr>
							<td><input type="text" name="a41" class="matrixinput4" value="0"></td>
							<td><input type="text" name="a42" class="matrixinput4" value="0"></td>
							<td><input type="text" name="a43" class="matrixinput4" value="0"></td>
							<td><input type="text" name="a44" class="matrixinput4" value="0"> </td>
						</tr>
						<tr>
							<td></td>
							<td class="center aligned"><input type="submit" name="submit" value="&#10003;"></td>
							<td></td>
							<td></td>
						</tr>
					</tbody>
				</table><br>


			</form>

		</template>

   </body>
   <script type="text/javascript">

var submit_form = function (event) {
   event.preventDefault();
   gl = VM.Storage.matrix;
   a11=event.target.a11.value;
   a12=event.target.a12.value;
   a13=event.target.a13.value;
   a14=event.target.a14.value;
   a21=event.target.a21.value;
   a22=event.target.a22.value;
   a23=event.target.a23.value;
   a24=event.target.a24.value;
   a31=event.target.a31.value;
   a32=event.target.a32.value;
   a33=event.target.a33.value;
   a34=event.target.a34.value;
   a41=event.target.a41.value;
   a42=event.target.a42.value;
   a43=event.target.a43.value;
   a44=event.target.a44.value;

   var gl=three.matrices.innerObjects;
   gl.m3.set(a11,a12,a13,a14,a21,a22,a23,a24,a31,a32,a33,a34,a41,a42,a43,a44);
   for (var i = 0; i < gl.vector.v3.length; i++) {
      gl.vector.v3[i].transvec.copy(gl.vector.v3[i]);
      gl.vector.v3[i].transvec.applyMatrix4(gl.m3);
   }
   gl.def = true;
   gl.vector.v3[1].transvec.copy(gl.vector.v3[1]);
   gl.vector.v3[1].transvec.applyMatrix4(gl.m3);
   console.log(gl.m3);

   elem=$("#katexfield5")
   katex.render("\\begin{pmatrix} "+
   a11+"&"+a12 +"&"+a13 +"&"+a14 +"\\\\"+
   a21+"&"+a22 +"&"+a23 +"&"+a24 +"\\\\"+
   a31+"&"+a32 +"&"+a33 +"&"+a34 +"\\\\"+
   a41+"&"+a42 +"&"+a43 +"&"+a44 +
   "\\end{pmatrix}",elem.get(0));
   return false;

}



$('.eqfield').remove();
//Reset to scrolltop when entering
window.scrollTo(0, 0);
container = document.getElementById('vmcontainer');
THREE.new("three",{element : container, plugins : ['core','controls'], controls : {klass : THREE.TrackballControls}});
three.Size.set({
   height: $(window).height()
});

el = $(three.renderer.domElement);
el.css("top","0");
el.css("position","fixed");
el.css("z-index","-1");
el.css("opacity","0.2");

uivisible = true;

//Get z key
if (typeof zkey == 'undefined') {
   // the variable is undefined
   zkey = true;
   $(window).bind('keypress', function(e) {
      var code = e.keyCode || e.which;
      //Z
      if(code == 122){
         VM.toggleUI();
      }
   });
}

three.sc1 = new THREE.Object3D();

/////////////////////////////////////////////////////////////////////////////////////////////////////
//// Scene 1 , Insert objects inside three.sc1
/////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////

three.matrices = three.matrices || {};
three.matrices.innerObjects = three.matrices.innerObjects || {};
var gl=three.matrices.innerObjects;
gl.scene = three.sc1;
gl.camera = three.camera;
gl.renderer = three.renderer;

gl.grid = new THREE.GridHelper(100,2);
gl.grid.rotation.x = Math.PI/2;
gl.grid.setColors("#aa82ee","#bb93ff");

gl.scene.add(gl.grid);

gl.grid = new THREE.GridHelper(100,2);
gl.grid.setColors("#aa82ee","#bb93ff");

gl.scene.add(gl.grid);

//Initial camera position
gl.camera.position.x = 17;
gl.camera.position.y = 12;
gl.camera.position.z = 8;
gl.camera.lookAt(gl.scene.position);


ticks = [-10,-8,-6,-4,-2,2,4,6,8,10];
gl.axes = new Array(3);
gl.axes[0] = new VM.Axis(ticks,{textSize:0.4});
gl.scene.add(gl.axes[0]);
gl.axes[1] = new VM.Axis(ticks,{textSize:0.4});
gl.axes[1].rotation.z = Math.PI/2;
gl.scene.add(gl.axes[1]);
gl.axes[2] = new VM.Axis(ticks,{textSize:0.4});
gl.axes[2].rotation.y = Math.PI/2;
gl.scene.add(gl.axes[2]);

gl.m3 = new THREE.Matrix4() ;
//console.log(gl.m3);
//Draw vctors
gl.vector = {v3: new Array(3), geom: new Array(3) };
for (var i = 0; i < gl.vector.v3.length; i++) {
   gl.vector.v3[i]=VM.V3(Math.random()*20,Math.random()*20,Math.random()*20)
   .multiplyScalar((Math.random()-0.5))
}

for (var i = 0; i < gl.vector.geom.length; i++) {
   var vborn = new VM.V3().copy(gl.vector.v3[i]);
   gl.vector.geom[i] = new VM.Vector(vborn);
   gl.vector.geom[i].setColor(0xf660AB);
   gl.scene.add(gl.vector.geom[i]);
}
var material = new THREE.LineBasicMaterial({
   color: 0x0000ff
});

for (var i = 0; i < gl.vector.v3.length; i++) {
   gl.vector.v3[i].transvec = VM.V3();
}

var geometry = new THREE.Geometry();
geometry.vertices.push(
   gl.vector.v3[0],
   gl.vector.v3[1],
   gl.vector.v3[2],
   gl.vector.v3[0]
);

var line = new THREE.Line( geometry, material );
gl.scene.add( line );

gl.line = line;
gl.def= false;

function f1(){
   /////////////////////////////////////////////////////////////////////////////////////////////////////
   //// Animation loop, Event 1
   /////////////////////////////////////////////////////////////////////////////////////////////////////
   /////////////////////////////////////////////////////////////////////////////////////////////////////
   var gl=three.matrices.innerObjects;
   var t = three.Time.now;

   step = t;

   gl.axes[0].lookAt(gl.camera);
   gl.axes[1].lookAt(gl.camera);
   gl.axes[2].lookAt(gl.camera);
   gl.axes[0].reposition();
   gl.axes[1].reposition();
   gl.axes[2].reposition();

   gl.camera.lookAt(gl.scene.position);
   //console.log(gl.m3.elements);
   if(gl.def){
      for (var i = 0; i < gl.vector.geom.length; i++) {
         gl.vector.geom[i].UpdateTarget(gl.vector.v3[i].transvec)
      }
   }

   gl.line.geometry.vertices[0] = gl.vector.geom[0].destination;
   gl.line.geometry.vertices[1] = gl.vector.geom[1].destination;
   gl.line.geometry.vertices[2] = gl.vector.geom[2].destination;
   gl.line.geometry.vertices[3] = gl.vector.geom[0].destination;

   gl.line.geometry.verticesNeedUpdate = true;
   /////////////////////////////////////////////////////////////////////////////////////////////////////
   //**************************************************************
   ///*************************************************************
}



three.scene.add(three.sc1);


three.on('update', function () {
   var t = three.Time.now;
   //// Three camera control is inside every f'()
   f1();
});



   </script>
</html>
